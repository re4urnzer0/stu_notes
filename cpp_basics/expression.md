# Expressions

## lvalue and rvalue
在`c`中，左值可以位于赋值语句的左侧，右值则不能。

而在`cpp`中，
- 当一个对象被用作右值的时候，**用的是对象的值（内容）**
- 当一个对象被用作左值的时候，**用的是对象的身份（在内存中的位置）**

一些运算符需要用到左值：
- `=`需要一个（非常量）左值作为左侧运算对象，得到的结果仍为一个左值
- `&`（取址运算符）作用于一个左值对象，返回一个指向该运算对象的指针
- 内置解引用运算符、下标运算符等的求值结果都是一个左值
- 内置类型和迭代器递增递减运算符（如`s.begin()++`）作用于左值运算对象

## Precedence and Associativity
对于在代码中出现的复合表达式（compound expression）求值，首先需要**根据其中运算符的优先级及其结合律将运算对象合理地组合在一起**。
- 高优先级 > 低优先级
- 优先级相等 $\rightarrow$ 根据结合律运算
  - 比如**算术运算符**均满足左结合律
    ```cpp
    6 + 3 * 4 / 2 + 2
    ```

## 求值顺序
在大多数情况下表达式不会明确运算对象按什么顺序求值，如
```cpp
int i = f_1() + f_2();
```
这里无法确定`f_1()`会先调用还是`f_2()`会先调用。

对于**没有指定执行顺序的运算符**来说，如果表达式**指向并且修改了同一个对象**，将会引发错误并且产生未定义行为（Undefined Behaviour），比如`<<`运算符没有明确规定何时以及如何对运算对象求值，那么以下代码就会产生未定义行为：
```cpp
int tmp = 0;
std::cout << i << " " << ++i << std::endl;
```
**括号无视优先级与结合律**

## 算术运算符（左结合律）
| Operator | Function | Usage       |
|----------|----------|-------------|
| +        | 正号       | +expr       |
| -        | 负号       | -expr       |
| *        | 乘法       | expr * expr |
| /        | 除法       | expr / expr |
| %        | 求余       | expr % expr |
| +        | 加法       | expr + expr |
| -        | 减法       | expr - expr |
运算符是作用于**任何算术类型或者能转换为算术类型的类型**。

算术运算异常的源头：
- 数学性质，如**除数是0**
- 计算机存储特性，如**溢出**，当计算结果超出该类型所能表示的范围（分为上溢出、下溢出）

## 各类运算符

### 逻辑和关系运算符
| Associativity | Operator | Function | Usage        |
|---------------|----------|----------|--------------|
| 右             | !        | 逻辑非      | !expr        |
| 左             | <        | 小于       | expr < expr  |
| 左             | <=        | 小于等于     | expr <= expr |
| 左             | >       | 大于       | expr > expr  |
| 左             | >=       | 大于等于     | expr >= expr |
| 左             | ==       | 相等       | expr == expr |
| 左             | !=       | 不等       | expr != expr |
| 左             | &&       | 逻辑与      | expr && expr |
| 左             | \|\|       | 逻辑或      | expr \|\| expr |

逻辑和关系运算符**均返回布尔类型（`boolen`）的值**

#### `&&`, `||`的求值策略
**短路求值（short-circuit evaluation）**：
- `&&`：当且仅当**左侧**运算对象为`true`时才对右侧求值
- `||`：当且仅当**右侧**运算对象为`false`时才对右侧求值

#### 布尔字面值
进行比较运算时除非比较的对象是布尔类型，否则**不要使用布尔字面值`true`和`false`作为运算对象**
- 对于算术对象或者指针对象来说，**任意非`0`值**，条件为真
- 当布尔值转换成其他算术类型时，**`false = 0`, `true = 1`**

### 赋值运算符
赋值运算符的左侧对象必须是一个可修改的左值：
```cpp
int i = 0, j = 0, k = 0;
const int ci = i;

// illegal statement

// literal is rvalue
1024 = k;
// arithmetic expression is rvalue
i + j = k;
// ci is constant
ci = k;
```
赋值运算的结果是它**左侧运算对象**，并且是一个左值，即赋值运算结果的类型就是左侧运算对象的类型，如果两侧类型不同，**则将右侧运算对象转换为左侧运算对象的类型**：
```cpp
k = 0;
// k = 3
k = 3.1415926;
```

#### 赋值运算符满足右结合律
```cpp
int ival, jval;
ival = jval = 0;
```
对于多重赋值语句中的每一个对象，它的类型或者与右边对象相同、或者可由右边对象进行类型转换得到：
```cpp
int ival, *pval;
// error, (int*) can't convert to int
ival = pval = 0;
std::string s1, s2;
s1 = s2 = "OK";
```
赋值运算符优先级较低

### 递增、递减运算符
有两种形式：前置形式`++i`（得到**递增后的值**），后置形式`i++`（得到**递增前的值**）
```cpp
int i = 0;
int j;
j = ++i; // j = 1, i = 1
j = i++; // j = 1, i = 2
```
除非必须，**否则不使用递增递减运算符的后置版本**

#### 在一条语句中混用解引用`*`与递增运算符
```cpp
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0)
  std::cout << *pbeg++ << std::endl;
```
后置递增运算符的优先级高于解引用运算符，所以`*pbeg++`等价于`*(pbeg++)`，输出`pbeg`开始时指向的那个元素，并将指针向前移动一个位置。
这种用法基于一个事实：后置运算符返回初始的未加一的值
- 如果返回的是加一之后的值，解引用该值将产生错误的结果

#### 运算对象可按任意顺序求值

### 成员访问运算符
点运算符`.`和箭头运算符`->`均可用于访问成员，前者用于获取类对象（class）的一个成员，后者与前者存在一种等价关系：`ptr->mem == (*ptr).mem`
```cpp
std::string s1 = "a string", *p = &s1;
auto n = s1.size();
n = (*p).size();
n = p->size();
```
- 箭头运算符作用于一个指针类型的运算对象，结果是一个左值
- 点运算符，如果成员所属的对象是左值结果就是左值，是右值结果就是右值

### 条件运算符
`?:`允许我们把简单的`if-else`逻辑嵌入到单个表达式中：
$$cond ? expr1 : expr2$$
`cond`为真则执行`expr1`，反之执行`expr2`：
```cpp
std::string final_grade = (grade < 60) ? "fail" : "pass";
```

#### 嵌套条件运算符
即允许在一个条件运算符的内部嵌套另一个条件运算符：
```cpp
std::string final_grade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```

### 位运算符
| Operator | Function | Usage          |
|----------|----------|----------------|
| ~        | 取反       | ~expr          |
| <<       | 左移       | expr1 << expr2 |
| >>       | 右移       | expr1 >> expr2 |
| &        | 位与       | expr&expr      |
| ^        | 位异或      | expr^expr      |
| \|        | 位或       | expr\|expr      |
